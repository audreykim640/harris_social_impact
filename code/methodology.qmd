---
title: "Rounding"
format: html
editor: visual
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

# Identifying discrete locations using rounding

## Set-up

```{r load library}
library(tidyverse)
```

```{r load data}
ground_truth <- read.csv("mobility_individuals.csv")
colnames(ground_truth) <- paste(colnames(ground_truth), 'truth', sep = '_')

trajectories <- read.csv("mobility_trajectories.csv") |>
  mutate(timestamp = as.POSIXct(timestamp, format = "%Y-%d-%mT%H:%M:%S"))
```

```{r how many hours per person per rounded location}
traj_rounded <- trajectories |>
  mutate(x_rounded = round(x), # round coordinate to nearest integer
         y_rounded = round(y)) |>
  group_by(individual_id, x_rounded, y_rounded) |>
  summarise(n_hours = n()) |> # count hours per unique (x,y) coordinate
  filter(n_hours >= 7) # remove some noise in the form of places where smaller amounts of time are spent
```

```{r further rounding of locations and also naming}

# reference: https://stackoverflow.com/questions/49208227/summarize-the-row-based-on-condition

hours_per_coor <- traj_rounded |>
  # collapsing x's
  group_by(individual_id, 
           x_rounded = case_when( # if...
                 lead(x_rounded) == x_rounded #...two rows have the same x...
                 & # ...and...
                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
                   ~ x_rounded, # group them into one row
                 TRUE ~ x_rounded) # otherwise, keep the row as is
               ) |>
  summarise(n_hours = sum(n_hours),
            y_rounded = round(mean(y_rounded), 1)) |>
  # same thing but now for collapsing y's
  group_by(individual_id, 
           y_rounded = case_when( 
                 lead(y_rounded) == y_rounded 
                 & 
                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1) 
                   ~ y_rounded, 
                 TRUE ~ y_rounded) 
               ) |>
  summarise(n_hours = sum(n_hours),
            x_rounded = round(mean(x_rounded), 1))

```

## Separating and labeling groups

```{r}

  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work

# identify folks' homes and their workplaces if they work full-time (30+ hours/wk)
labeled <- hours_per_coor |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours ~ "home",
           n_hours >= 30 ~ "work - full-time")
         )

# id folks who work full-time
full_time <- labeled |>
  filter(location == "work - full-time")

# remove folks who work full-time as well as "home" rows so that we can look at part-time workers
not_ft_or_home <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  filter(is.na(location))

# assume that folks who aren't working full-time and who spend at least 15 hours in the same non-home 
# place is working part-time at that location
part_time <- not_ft_or_home |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours & n_hours > 15 ~ "work - part-time"
           )
         ) |>
  filter(location == "work - part-time")

# see if anyone is unaccounted for
# full group minus people designated as full-time minus people designated as part-time
# we hope for no more unlabeled locations -> success! only entries with "home" are left
labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 
  
# everyone remaining is assumed to be unemployed, as their only accounted-for location is home, 
# and they have no unaccounted for locations
unemployed <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 

```

```{r sanity check}
# check number of people in each group (full-time, part-time, unemployed)
full_time_ids <- unique(full_time$individual_id)
part_time_ids <- unique(part_time$individual_id)
unemployed_ids <- unique(unemployed$individual_id)

length(full_time_ids) + length(part_time_ids) + length(unemployed_ids)

# should equal 200 -> success! everyone is accounted for :)
```

## Putting everything together!

```{r enmployment status}

# `labeled` includes home locations for all people and people's workplaces if full-time
# need to add part-time work locations and indicate those who are unemployed

labeled_all_employment <- labeled |>
  # adding part-time work labels
  left_join(part_time, by = c("individual_id", "n_hours", "x_rounded", "y_rounded")) |>
  mutate(location.x = coalesce(location.x, location.y)) |> # combine part-time entries into `location`
  rename(location = location.x) |> # rename column from join
  select(-c(location.y, max_hours.x, max_hours.y)) |> # disregard unneeded columns
  # splitting work label and location label before adding "unemployed labels"
  separate(col = location, sep = " - ", into = c("location", "employment_status")) |>
  # adding unemployed labels
  mutate(employment_status = case_when(
    !is.na(employment_status) ~ employment_status, # keep existing entries
    individual_id %in% unemployed_ids ~ "unemployed" # check if  person's id is in list of unemployed ids
          )
        )
```

```{r patching rounding oversight}

## adding labels about locations

## patching up oversight with rounding locations -- I don't know which quadrants "5"s should be in 
## I will address these cases separately instead of restarting and breaking everything

## for people whose rounded coordinates are 5, I will look at their original data and count how many
## hours were spent in [4.5, 5) and how many in (5, 5.5). 

x_rounded_5 <- labeled_all_employment |>
  filter(x_rounded == 5) |> # only look at people whose coordinates rounded to 5
  select(individual_id, y_rounded, location) |>
  left_join(trajectories, by = "individual_id") |> # join with original points
  filter(y_rounded == round(y) | y_rounded == round(y) + 0.5 | y_rounded == round(y) - 0.5) |> # make sure we're talking about the right location by matching y's
  group_by(individual_id, y_rounded, location) |>
  summarize(x_median = median(x)) # make a new estimate for the x-coordinate that had rounded to 5

# same thing but for y's
y_rounded_5 <- labeled_all_employment |>
  filter(y_rounded == 5) |>
  select(individual_id, x_rounded, location) |>
  left_join(trajectories, by = "individual_id") |>
  filter(x_rounded == round(x) | x_rounded == round(x) + 0.5 | x_rounded == round(x) - 0.5) |> 
  group_by(individual_id, x_rounded, location) |>
  summarize(y_median = median(y))

```

```{r add district labels}

labeled_employment_and_districts <- labeled_all_employment |> 
  left_join(x_rounded_5, by = c("individual_id", "location", "y_rounded")) |>
  left_join(y_rounded_5, by = c("individual_id", "location", "x_rounded")) |>
  mutate(
    district_ns = case_when(
      y_rounded < 5 ~ "South",
      y_rounded > 5 ~ "North",
      y_median < 5 ~ "South",
      y_median > 5 ~ "North",
             ),
    district_ew = case_when(
      x_rounded < 5 ~ "west",
      x_rounded > 5 ~ "east",
      x_median < 5 ~ "west",
      x_median > 5 ~ "east"
             ),
    district = paste0(district_ns, district_ew)
        )
```

```{r reformat df}
# reformat to have the desired columns:
# individual_id, home_quadrant, work_quadrant, employment_status

reformatted <- labeled_employment_and_districts |>
  filter(!is.na(location)) |>
  pivot_wider(names_from = location, values_from = district) |>
  select(individual_id, home, work, employment_status) |>
  group_by(individual_id) |> # reference: https://stackoverflow.com/questions/45515218/combine-rows-in-data-frame-containing-na-to-make-complete-row
  fill(everything(), .direction = "downup") |> # combine work and home rows into one row
  slice(1) |>
  rename(home_quadrant = home,
         work_quadrant = work
         )
```

## Export .csv

```{r}
write.csv(reformatted, "predictions.csv")
```
