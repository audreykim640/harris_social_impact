---
title: "Rounding"
format: html
editor: visual
---

## Identifying discrete locations

```{r}
library(tidyverse)
```

```{r}
ground_truth <- read.csv("mobility_individuals.csv")
colnames(ground_truth) <- paste(colnames(ground_truth), 'truth', sep = '_')

trajectories <- read.csv("mobility_trajectories.csv") |>
  mutate(timestamp = as.POSIXct(timestamp, format = "%Y-%d-%mT%H:%M:%S"))
```

```{r how many hours per person per rounded location}
traj_rounded <- trajectories |>
  mutate(x_rounded = round(x),
         y_rounded = round(y)) |>
  group_by(individual_id, x_rounded, y_rounded) |>
  summarise(n_hours = n()) |>
  filter(n_hours >= 3)
```

Person 0 spends 68 hours at (10,2) and 71 hours at (10,3). Other people have similar patterns. I would like to coalesce these locations into the same place, but I worry about people like 192, who appears to work very close to their home. I will try combining groups that are very similar if at least the x-coor or y-coor is common and then compare against the ground truth.

```{r}
head(ground_truth)
traj_rounded |>
  right_join(ground_truth, by = c("individual_id" = "individual_id_truth"))
```

```{r further rounding of locations and also naming}

# reference: https://stackoverflow.com/questions/49208227/summarize-the-row-based-on-condition

hours_per_coor <- traj_rounded |>
  # collapsing x's
  group_by(individual_id, 
           x_rounded = case_when( # if...
                 lead(x_rounded) == x_rounded #...two rows have the same x...
                 & # ...and...
                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
                   ~ x_rounded, # group them into one row
                 TRUE ~ x_rounded) # otherwise, keep the row as is
               ) |>
  summarise(n_hours = sum(n_hours),
            y_rounded = round(mean(y_rounded), 1)) |>
  # same thing but now for collapsing y's
  group_by(individual_id, 
           y_rounded = case_when( # 
                 lead(y_rounded) == y_rounded 
                 & 
                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1) 
                   ~ y_rounded, 
                 TRUE ~ y_rounded) 
               ) |>
  summarise(n_hours = sum(n_hours),
            x_rounded = round(mean(x_rounded), 1))
       
# this is not perfect -- I can see that a couple of person 14's locations should be joined

  # if two rows have the same y and x's that are one apart, join them
  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work
  # 

```

## Separating and labeling groups

```{r}

  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work

# identify folks' homes and their workplaces if they work full-time (30+ hours/wk)
labeled <- hours_per_coor |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours ~ "home",
           n_hours >= 30 ~ "work - full-time")
         )

# id folks who work full-time
full_time <- labeled |>
  filter(location == "work - full-time")

# remove folks who work full-time as well as "home" rows so that we can look at part-time workers
not_ft_or_home <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  filter(is.na(location))

# assume that folks who aren't working full-time and who spend at least 15 hours in the same non-home 
# place is working part-time at that location
part_time <- not_ft_or_home |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours & n_hours > 15 ~ "work - part-time"
           )
         ) |>
  filter(location == "work - part-time")

# see if anyone is unaccounted for
# full group minus people designated as full-time minus people designated as part-time
# we hope for no more unlabeled locations -> success! only entries with "home" are left
labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 
  
# everyone remaining is assumed to be unemployed, as their only accounted-for location is home, 
# and they have no unaccounted for locations
unemployed <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 

```

```{r sanity check}
# check number of people in each group (full-time, part-time, unemployed)
full_time_ids <- unique(full_time$individual_id)
part_time_ids <- unique(part_time$individual_id)
unemployed_ids <- unique(unemployed$individual_id)

length(full_time_ids) + length(part_time_ids) + length(unemployed_ids)

# should equal 200 -> success! everyone is accounted for :)
```

## Putting everything together!

```{r}

# `labeled` includes home locations for all people and people's workplaces if full-time
# need to add part-time work locations and indicate those who are unemployed

labeled_all_employment <- labeled |>
  # adding part-time work labels
  left_join(part_time, by = c("individual_id", "n_hours", "x_rounded", "y_rounded")) |>
  mutate(location.x = coalesce(location.x, location.y)) |> # combine part-time entries into `location`
  rename(location = location.x) |> # rename column from join
  select(-c(location.y, max_hours.x, max_hours.y)) |> # disregard unneeded columns
  # splitting work label and location label before adding "unemployed labels"
  separate(col = location, sep = " - ", into = c("location", "employment_status")) |>
  # adding unemployed labels
  mutate(employment_status = case_when(
    !is.na(employment_status) ~ employment_status, # keep existing entries
    individual_id %in% unemployed_ids ~ "unemployed" # check if  person's id is in list of unemployed ids
          )
        )

## adding labels about locations. I have shot myself in the foot with rounding locations,
## as I don't know which quadrants "5"s should be in 
## I will address these cases separately instead of restarting and breaking everything

## for people whose rounded coordinates are 5, I should look at their original data and count how many
## hours were spent in [4.5, 5) and how many in (5, 5.5). 

rounded_5 <- labeled_all_employment |>
  filter(x_rounded == 5 | y_rounded == 5) |>
  mutate(coor5 = case_when(
      x_rounded == 5 ~ "x",
      y_rounded == 5 ~ "y"
            )
        )

rounded_5$individual_id |>
  unique() |>
  left_join()

labeled_employment_and_districts <- labeled_all_employment |> 
  mutate(
    district_ns = case_when(
      y_rounded < 5 ~ "South",
      y_rounded > 5 ~ "North"
             ),
    district_ew = case_when(
      x_rounded < 5 ~ "west",
      x_rounded > 5 ~ "east"
             ),
    district = paste0(district_ns, district_ew)
        )
```

```{r reformat df}
# individual_id, home_quadrant, work_quadrant, employment_status

# reference: https://stackoverflow.com/questions/45515218/combine-rows-in-data-frame-containing-na-to-make-complete-row

reformatted <- labeled_employment_and_districts |>
  filter(!is.na(location)) |>
  pivot_wider(names_from = location, values_from = district) |>
  select(-c(n_hours, x_rounded, y_rounded, district_ns, district_ew)) |>
  group_by(individual_id) %>%
  fill(everything(), .direction = "downup") %>%
  slice(1) |>
  rename(home_district = home,
         work_district = work
         )
```

```{r check results}
ground_truth |>
  left_join(reformatted, by = c("individual_id_truth" = "individual_id")) |>
  mutate(check_empl_stat = ifelse(employment_status_truth == employment_status, 1, 0),
         check_home_dist = ifelse(home_dist_truth == home_district, 1, 0),
         check_empl_dist = ifelse(work_dist_truth == work_district, 1, 0)
  )

```


## Graveyard

```{r graveyard}
# traj_rounded |>
#   group_by(individual_id, 
#            x = case_when( # if...
#                 lead(x_rounded) == x_rounded #...two rows have the same x...
#                 & # ...and...
#                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
#                 ~ x_rounded, # group them into one row
#                 TRUE ~ x_rounded), # otherwise, keep the row as is
#            y = case_when( # same but for if y's are the same
#                 lead(y_rounded) == y_rounded
#                 & 
#                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1)
#                 ~ y_rounded, 
#                 TRUE ~ y_rounded)
#           ) |>
#    summarise(n_hours = sum(n_hours))
#    
```
