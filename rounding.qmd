---
title: "Rounding"
format: html
editor: visual
---

## Identifying discrete locations

```{r}
library(tidyverse)
```

```{r}
ground_truth <- read.csv("mobility_individuals.csv")
colnames(ground_truth) <- paste(colnames(ground_truth), 'truth', sep = '_')

trajectories <- read.csv("mobility_trajectories.csv") |>
  mutate(timestamp = as.POSIXct(timestamp, format = "%Y-%d-%mT%H:%M:%S"))
```

```{r how many hours per person per rounded location}
traj_rounded <- trajectories |>
  mutate(x_rounded = round(x),
         y_rounded = round(y)) |>
  group_by(individual_id, x_rounded, y_rounded) |>
  summarise(n_hours = n()) |>
  filter(n_hours >= 3)
```

Person 0 spends 68 hours at (10,2) and 71 hours at (10,3). Other people have similar patterns. I would like to coalesce these locations into the same place, but I worry about people like 192, who appears to work very close to their home. I will try combining groups that are very similar if at least the x-coor or y-coor is common and then compare against the ground truth.

```{r}
head(ground_truth)
traj_rounded |>
  right_join(ground_truth, by = c("individual_id" = "individual_id_truth"))
```

```{r further rounding of locations and also naming}

# reference: https://stackoverflow.com/questions/49208227/summarize-the-row-based-on-condition

hours_per_coor <- traj_rounded |>
  # collapsing x's
  group_by(individual_id, 
           x_rounded = case_when( # if...
                 lead(x_rounded) == x_rounded #...two rows have the same x...
                 & # ...and...
                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
                   ~ x_rounded, # group them into one row
                 TRUE ~ x_rounded) # otherwise, keep the row as is
               ) |>
  summarise(n_hours = sum(n_hours),
            y_rounded = round(mean(y_rounded), 1)) |>
  # same thing but now for collapsing y's
  group_by(individual_id, 
           y_rounded = case_when( # 
                 lead(y_rounded) == y_rounded 
                 & 
                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1) 
                   ~ y_rounded, 
                 TRUE ~ y_rounded) 
               ) |>
  summarise(n_hours = sum(n_hours),
            x_rounded = round(mean(x_rounded), 1))
       
# this is not perfect -- I can see that a couple of person 14's locations should be joined

  # if two rows have the same y and x's that are one apart, join them
  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work
  # 

```

## Separating and labeling groups

```{r}

  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work

# identify folks' homes and their workplaces if they work full-time (30+ hours/wk)
labeled <- hours_per_coor |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours ~ "home",
           n_hours >= 30 ~ "work - full-time")
         )

# id folks who work full-time
full_time <- labeled |>
  filter(location == "work - full-time")

# remove folks who work full-time as well as "home" rows so that we can look at part-time workers
not_ft_or_home <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  filter(is.na(location))

# assume that folks who aren't working full-time and who spend at least 15 hours in the same non-home 
# place is working part-time at that location
part_time <- not_ft_or_home |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours & n_hours > 15 ~ "work - part-time")
         )

# see if anyone is unaccounted for
labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 
  
# everyone remaining is assumed to be unemployed, as their only accounted-for location is home
unemployed <- labeled |>
  anti_join(full_time, by = "individual_id") |>
  anti_join(part_time, by = "individual_id") 

```

```{r sanity check}
full_time_ids <- unique(full_time$individual_id)
part_time_ids <- unique(part_time$individual_id)
unemployed_ids <- unique(unemployed$individual_id)

length(full_time_ids) + length(part_time_ids) + length(unemployed_ids)

# everyone is accounted for! :)
```

## Putting everything together!

```{r graveyard}
# traj_rounded |>
#   group_by(individual_id, 
#            x = case_when( # if...
#                 lead(x_rounded) == x_rounded #...two rows have the same x...
#                 & # ...and...
#                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
#                 ~ x_rounded, # group them into one row
#                 TRUE ~ x_rounded), # otherwise, keep the row as is
#            y = case_when( # same but for if y's are the same
#                 lead(y_rounded) == y_rounded
#                 & 
#                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1)
#                 ~ y_rounded, 
#                 TRUE ~ y_rounded)
#           ) |>
#    summarise(n_hours = sum(n_hours))
#    
```
