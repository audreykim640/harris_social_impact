---
title: "Rounding"
format: html
editor: visual
---

## Rounding

```{r}
library(tidyverse)
```

```{r}
ground_truth <- read.csv("mobility_individuals.csv")
colnames(ground_truth) <- paste(colnames(ground_truth), 'truth', sep = '_')

trajectories <- read.csv("mobility_trajectories.csv") |>
  mutate(timestamp = as.POSIXct(timestamp, format = "%Y-%d-%mT%H:%M:%S"))
```


```{r how many hours per person per rounded location}
traj_rounded <- trajectories |>
  mutate(x_rounded = round(x),
         y_rounded = round(y)) |>
  group_by(individual_id, x_rounded, y_rounded) |>
  summarise(n_hours = n()) |>
  filter(n_hours >= 3)
```

Person 0 spends 68 hours at (10,2) and 71 hours at (10,3). Other people have similar patterns. I would like to coalesce these locations into the same place, but I worry about people like 192, who appears to work very close to their home. I will try combining groups that are very similar if at least the x-coor or y-coor is common and then compare against the ground truth.

```{r}
head(ground_truth)
traj_rounded |>
  right_join(ground_truth, by = c("individual_id" = "individual_id_truth"))
```

```{r further rounding of locations and also naming}

# reference: https://stackoverflow.com/questions/49208227/summarize-the-row-based-on-condition

hours_per_coor <- traj_rounded |>
  # collapsing x's
  group_by(individual_id, 
           x_rounded = case_when( # if...
                 lead(x_rounded) == x_rounded #...two rows have the same x...
                 & # ...and...
                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
                   ~ x_rounded, # group them into one row
                 TRUE ~ x_rounded) # otherwise, keep the row as is
               ) |>
  summarise(n_hours = sum(n_hours),
            y_rounded = round(mean(y_rounded), 1)) |>
  # same thing but now for collapsing y's
  group_by(individual_id, 
           y_rounded = case_when( # 
                 lead(y_rounded) == y_rounded 
                 & 
                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1) 
                   ~ y_rounded, 
                 TRUE ~ y_rounded) 
               ) |>
  summarise(n_hours = sum(n_hours),
            x_rounded = round(mean(x_rounded), 1))
       
# this is not perfect -- I can see that a couple of person 14's locations should be joined

  # if two rows have the same y and x's that are one apart, join them
  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work
  # 

```

```{r}

  # label location with most hours as home
  # label home location with Southeast, etc
  # label location with second most hours as work
  # 

hours_per_coor |>
  group_by(individual_id) |>
  mutate(max_hours = n_hours[which.max(n_hours)],
         location = case_when(
           n_hours == max_hours ~ "home",
           n_hours >= 40 ~ "work - full-time")
         )

```


```{r graveyard}
# traj_rounded |>
#   group_by(individual_id, 
#            x = case_when( # if...
#                 lead(x_rounded) == x_rounded #...two rows have the same x...
#                 & # ...and...
#                 lead(y_rounded) == (y_rounded + 1) | (y_rounded - 1) # ...the y's that are one apart
#                 ~ x_rounded, # group them into one row
#                 TRUE ~ x_rounded), # otherwise, keep the row as is
#            y = case_when( # same but for if y's are the same
#                 lead(y_rounded) == y_rounded
#                 & 
#                 lead(x_rounded) == (x_rounded + 1) | (x_rounded - 1)
#                 ~ y_rounded, 
#                 TRUE ~ y_rounded)
#           ) |>
#    summarise(n_hours = sum(n_hours))
#    
```

